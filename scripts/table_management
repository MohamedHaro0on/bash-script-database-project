#!/usr/bin/bash

source ../configs/config
source ./utils

create_table() {
    echo -e "\nCreate Table"
    echo "============================================== "
    echo $DB_NAME 
    # Check database existence
    check_db_exists || return  # returns 1 if database does not exist
    
    # Get and validate table name
    while true; do
        read -p "Enter table name: " table_name
        if ! validate_table_name "$table_name"; then
            continue
        fi
        if check_table_exists "$table_name"; then
            echo "Error: Table already exists!"
            continue
        fi
        break
    done
    
    # Create table structure
    if ! mkdir "$ACTIVE_DB_PATH/$table_name" 2>/dev/null; then
        echo "Error: Failed to create table directory"
        return 1
    fi
    touch "$ACTIVE_DB_PATH/$table_name/metadata"
    touch "$ACTIVE_DB_PATH/$table_name/data"
    
    # Get column count
    while true; do
        read -p "Enter number of columns: " col_count
        if validate_number "$col_count" 1 100; then
            break
        fi
    done
    
    # Get column details
    metadata=""
    # Primary Key Check
    pk=0
    for ((i=1; i<=$col_count; i++)); 
    do
        # Get and validate column name
        while true; do
            read -p "Enter name for column $i: " col_name
            if validate_column_name "$col_name"; then
                break
            fi
        done
        
        # Display data types
        echo -e "\nAvailable data types:"
        for ((j=0; j<${#SUPPORTED_DATATYPES[@]}; j++)); do
            echo "$((j+1))) ${SUPPORTED_DATATYPES[j]}"
        done
        
        # Get data type
        while true; do
            read -p "Select data type for $col_name (1-${#SUPPORTED_DATATYPES[@]}): " type_choice
            if validate_number "$type_choice" 1 ${#SUPPORTED_DATATYPES[@]}; then
                selected_type=${SUPPORTED_DATATYPES[$((type_choice-1))]}
                break
            fi
        done
       # Check if this column should be the primary key
        if [ $pk -eq 0 ]
        then
        	read -p "Do you Want to make $col_name Primary Key (y/n): " checkPk
        	if [[ $checkPk = "y" ]]
        	then
        		metadata+="$col_name:$selected_type:PK"
        		pk=1
        	else
        		metadata+="$col_name:$selected_type"
        	fi
        else
            metadata+="$col_name:$selected_type"
        fi    
        
        if [ $i -ne $col_count ]
        then
        	metadata+=","
        fi
    done
    
    # Ensure at least one PK is set
    if [ $pk -eq 0 ]; then
    	echo "Error: At least one column must be set as a Primary Key."
    	return 1
    fi
    
    # Save metadata
    echo "$metadata" > "$ACTIVE_DB_PATH/$table_name/metadata"
    echo "Table '$table_name' created successfully!"
}

list_tables() {
    echo -e "\nList Tables"
    echo "============================================== "
    
    # Check database existence
    check_db_exists || return 1
    
    # Display tables
    local table_count=0
    echo "CHECK:$ACTIVE_DB_PATH"
    pwd

    for table in "$ACTIVE_DB_PATH"/* ; do
        if [ -d "$table" ] && [ -f "$table/metadata" ]; then
            ((table_count++))
            table_name=$(basename "$table")
            
            if [ -f "$table/metadata" ]; then
                metadata=$(cat "$table/metadata")
                records_count=$(wc -l < "$table/data" 2>/dev/null || echo 0)
                
                echo -e "\nTable: $table_name"
                echo "Records: $records_count"
                echo "Columns:"
                
                IFS=',' read -ra COLUMNS <<< "$metadata"
                for column in "${COLUMNS[@]}"; do
                    IFS=':' read -ra COL_INFO <<< "$column"
                    printf "  %-20s %-10s\n" "${COL_INFO[0]}" "${COL_INFO[1]}"
                done
                echo "------------------------"
            else
                echo "Table '$table_name' (metadata not found)"
            fi
        fi
    done
    
    if [ $table_count -eq 0 ]; then
        echo "No tables found"
        return 1
    fi
    
    echo -e "\nTotal tables: $table_count"
}

drop_table() {
    echo -e "\nDrop Table"
    echo "============================================== "
    
    # Check database and display tables
    check_db_exists || return 1
    display_tables || return 1
    
    # Get table selection
    while true; do
        read -p $'\nEnter table number to drop (or 0 to cancel): ' choice
        
        if [ "$choice" -eq 0 ]; then
            echo "Operation cancelled"
            return 0
        fi
        
        if validate_number "$choice" 1 ${#table_names[@]}; then
            selected_table=${table_names[$choice]}
            break
        fi
    done
    
    # Confirm and execute
    if confirm_action "Are you sure you want to drop table '$selected_table'?"; then
        if rm -r "$ACTIVE_DB_PATH/$selected_table" 2>/dev/null; then
            echo "Table '$selected_table' dropped successfully"
        else
            echo "Error dropping table '$selected_table'"
            return 1
        fi
    fi
}

rename_table() {
    echo -e "\nRename Table"
    echo "============================================== "
    
    # Check database and display tables
    check_db_exists || return 1
    display_tables || return 1
    
    # Get table selection
    while true; do
        read -p $'\nEnter table number to rename (or 0 to cancel): ' choice
        
        if [ "$choice" -eq 0 ]; then
            echo "Operation cancelled"
            return 0
        fi
        
        if validate_number "$choice" 1 ${#table_names[@]}; then
            selected_table=${table_names[$choice]}
            break
        fi
    done
    
    # Get new name
    while true; do
        read -p "Enter new table name: " new_table_name
        if ! validate_table_name "$new_table_name"; then
            continue
        fi
        if check_table_exists "$new_table_name"; then
            echo "Error: Table '$new_table_name' already exists"
            continue
        fi
        break
    done
    
    # Confirm and execute
    if confirm_action "Rename table '$selected_table' to '$new_table_name'?"; then
        if mv "$ACTIVE_DB_PATH/$selected_table" "$ACTIVE_DB_PATH/$new_table_name" 2>/dev/null; then
            echo "Table renamed successfully"
            echo "'$selected_table' â†’ '$new_table_name'"
        else
            echo "Error renaming table"
            return 1
        fi
    fi
}

insert_into_table() {

    echo -e "\nInsert Into Table"
    echo "============================================== "
    
    # Check database and display tables
    check_db_exists || return 1
    display_tables || return 1
   
    # Get table selection
    while true; do
        read -p $'\nSelect table number to insert into (or 0 to cancel): ' choice
        
        if validate_number "$choice" 0 ${#table_names[@]}; then
            selected_table=${table_names[$choice]}
            break
        fi
        if [ "$choice" -eq 0 ]; then
            echo "Operation cancelled"
            return 0
        fi
    done
    
    # Read metadata
    metadata_file="$ACTIVE_DB_PATH/$selected_table/metadata"
    if [ ! -f "$metadata_file" ]; then
        echo "Metadata file not found for $selected_table"
        return 1
    fi
    IFS=',' read -ra COLUMNS <<< "$(cat "$metadata_file")"
    
    # Get values
    data_string=""
    echo -e "\nEnter values for each column:"
    for column in "${COLUMNS[@]}"; do
        IFS=':' read -ra COL_INFO <<< "$column"
        col_name=${COL_INFO[0]}
        col_type=${COL_INFO[1]}
        is_pk=${COL_INFO[2]}
        while true; do
            read -p "$col_name ($col_type): " value
            if validate_data_type "$value" "$col_type"; then
                break
            fi
        done
        
        if [ -z "$data_string" ]; then
            data_string="$value"
        else
            data_string="$data_string:$value"
        fi
    done
    
    # Save record
    data_file="$ACTIVE_DB_PATH/$selected_table/data"
    if echo "$data_string" >> "$data_file"; then
        echo -e "\nRecord inserted successfully!"
    else
        echo -e "\nError inserting record!"
        return 1
    fi
}
# UPDATE Functionality
update_table(){
echo -e "\nUpdate Table"
echo "============================================== "
    
#1-Prompt the user for the table name.   
# Ensure An Active DataBase is selected 
if [[ -z "$ACTIVE_DB_PATH" ]]
then
	echo "No Database Selected! Please Connect To a Database First."
	return 1
fi

# Get List Of Tables
local tables=($(ls "$ACTIVE_DB_PATH")) # Store tables in an array

if [[ ${#tables[@]} -eq 0 ]]
then
	echo "No Tables Found in Database $ACTIVE_DB_PATH"
	return 1
fi

# Display Tables
echo -e "\n Available Tables: "
local index=1
for table in "${tables[@]}"
do
	echo "$index) $table"
	((index++))
done

# Get User Selection
while true
do
	read -p $'\n Select Table Number To Update(or 0 To Cancel) : ' choice
	if [[ $choice -eq 0 ]] 
	then
		echo "Operation Cancelled"
		return 0
	fi
	if [[ $choice -ge 1 && $choice -le ${#tables[@]} ]]
	then
		selected_table="${tables[$((choice-1))]}"
		break
	else
		echo "Inavlid Selection. Please,Enter a Number Between 1 & ${#tables[@]}"
	fi
done
#2-Read Metadata file & data file
metadata_file="$ACTIVE_DB_PATH/$selected_table/metadata"
data_file="$ACTIVE_DB_PATH/$selected_table/data"

if [[ ! -f "$metadata_file" || ! -f "$data_file" ]]; 
then
        echo "Error: Table $selected_table Does Not Exist!"
        return 1
fi

#Read metadata (Extract Column Names)
IFS=',' read -ra COLUMNS < "$metadata_file"
  
#3-Prompt the user for the column to search by and the value.
# Display Columns
echo -e "\n Available Columns: "
local index=1
for column in "${COLUMNS[@]}"
do
	echo "$index) $column"
	((index++))
done

# Get User Selection
while true
do
	read -p $'\n Select Column Number To Update(or 0 To Cancel) : ' choice
	if [[ $choice -eq 0 ]] 
	then
		echo "Operation Cancelled"
		return 0
	fi
	if [[ $choice -ge 1 && $choice -le ${#COLUMNS[@]} ]]
	then
        	IFS=":" read -r search_column _ <<< "${COLUMNS[$((choice-1))]}"
		column_index=$((choice-1))
		break
	else
		echo "Inavlid Selection. Please,Enter a Number Between 1 & ${#COLUMNS[@]}"
	fi
done

read -p "Enter value to search for: " search_value

    # Identify column index
    column_index=-1
    for i in "${!COLUMNS[@]}"; do
        IFS=":" read -r col_name col_type <<< "${COLUMNS[i]}"
        if [[ "$col_name" == "$search_column" ]]; then
            column_index=$i
            break
        fi
    done

    if [[ $column_index -eq -1 ]]; then
        echo "Error: Column $search_column Not Found!"
        return 1
    fi


#Search For The Record In Data File
match_found=false
while IFS= read -r line
do
	IFS=":" read -ra values <<< "$line"
	#echo "Checking line: $line"  # Debugging statement
	if [[ "${values[column_index]}" == "$search_value" ]]
	then
		match_found=true
		old_record="$line"
		#echo "Match Found: $old_record"  # Debugging statement
		break
	fi
done < "$data_file"	

if [[ "$match_found" == false ]]
then
	echo "Error: No Matching Record Found!"
	return 1
fi

# Display The Current Record
echo -e "\nCurrent Record: $old_record"
new_record=""
updated=false  # Track if any changes were made
for i in "${!COLUMNS[@]}"
do
        IFS=":" read -r col_name col_type <<< "${COLUMNS[i]}"
        if [[ "$col_name" == "$search_column" ]] 
        then
        	while true 
        	do
        		read -p "Enter new value for $col_name ($col_type) (leave empty to keep current): " new_value
        		if [[ -z "$new_value" ]]
        		then
        			new_value="${values[i]}"
        			break
        		fi
        			# Validate Value Based On Type
				if validate_data_type "$new_value" "$col_type" 
				then
					updated=true  # Mark that an update occurred
					break
				else
					echo "Invalid Input for $col_name. Please enter a valid $col_type."
				fi
		done
	fi
	# Construct the new record
        if [[ -z "$new_record" ]]; then
            new_record="$new_value"
        else
            new_record="$new_record:$new_value"
        fi
done
    
    if [[ "$updated" == true ]] 
    then
    	
 	# Replace the old record with the new one
 	awk -F':' -v col="$((column_index+1))" -v old="$search_value" -v new="$new_value" 'BEGIN {OFS=":"} 
    	{
        	if ($col == old) $col = new;
        	print $0;
    	}' "$data_file" > temp_file && mv temp_file "$data_file"
	echo -e "\n Record Updated Successfully!"
    else
    	    echo -e "\n No changes were made."
    fi
}
